# JAVA集合(1)

## 抽象类
意义：在抽象类中，我们可以定义一些抽象的方法，这样就会存在一个约束，而子类必须实现我们定义的方法，抽象类中的方法名称，子类又不能修改，这样就能很好的实现多态的机制，有了多态的机制，我们在运行期就可以动态的调用子类的方法。从而在运行期可以灵活的互换实现。
- 抽象类是不能被实例化的，就像现实世界中的人，其实是抽象的，张三才是具体的人的一个实例
- 抽象的方法只需在抽象类中，提供声明。抽象类中的抽象方法只有方法体，不需要在抽象类中进行实现。
- 如果一个类中含有抽象方法，那么这个类必须定义成抽象类，当然，抽象类中，可以没有抽象方法
- 如果一个子类继承了抽象类，那么，抽象类中的所有的抽象方法必须被子类复写。如果在子类中不复写该抽象方法，那么必须将此方法声明为抽象方法
- 抽象类和方法都不能被final修饰，因为抽象类就是用来被继承，抽象方法用来实现的，而final修饰后的类，不能被继承，两者有冲突，final修饰的方法也不能被覆盖

## 抽象类和接口的相同点和不同
### 共同点
- 都可以定义抽象方法
- 都不能实例化对象
- 定义的抽象方法都需要被重写
- 都可以定义public static方法，public static final常量（接口中一般不这么用）
### 不同点
- 抽象类要被子类继承，而接口是用来被子类实现的。
- 接口只能做方法声明，不能有方法的实现（接口默认方法实现除外），抽象类中不仅可以作方法声明，也可以做方法实现。
- 接口是设计的结果，抽象类是重构的结果。抽象类主要用来抽象类别，强调的是所属关系，接口主要用来抽象功能，强调的是特定功能的实现。
#### 面试用
- 意义不同：抽象类是对事物更高层级的抽象，接口是对功能的封装
- 定义方式不同：抽象类用 abstract class定义，接口用interface定义
- 内容不同：抽象类中除了抽象方法外，还可以定义构造方法等普通类中定义的所有成员，- 接口不能定义构造方法
- 使用方式不同：抽象类需要被子类extends继承，接口需要被实现类implements实现
- 类只支持单继承，接口支持多实现
- 应用场景不同：一般情况下，对类进行功能的扩展，优先选择接口。除了扩展功能外，还需要保存不同的数据，只能选择抽象类。抽象类的抽象方法需要子类重写，抽象类还可以约束所有的子类都具有相同的功能。
## 接口继承关系和实现
* 集合类存放于 Java.util 包中， 主要有 3 种： set(集）、 list(列表包含 Queue）和 map(映射)。
* Collection： Collection 是集合 List、 Set、 Queue 的最基本的接口。
* Iterator：迭代器，可以通过迭代器遍历集合中的数据
* Map：是映射表的基础接口
![java_Page45_Image1.jpg](/mymd/imgs/5b20a7cc-5fcf-447f-ad21-2622865d3acajava_Page45_Image1.jpg)
![java_Page46_Image1.jpg](/mymd/imgs/733be999-4983-4d5f-a824-1e7bdcfd8a00java_Page46_Image1.jpg)
## List
Java 的 List 是非常常用的数据类型。 List 是有序的 Collection。 Java List 一共三个实现类：
分别是 ArrayList、 Vector 和 LinkedList。
### ArrayList（数组）
ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔， 当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。 当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。
### Vector（ 数组实现、 线程同步）
Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。
### LinkList（链表）
LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。
## Set
Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素， 值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号） 判断的， 如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。
### HashSet（ Hash 表）
* 哈希表边存放的是哈希值。 HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ， HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素
* 哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。
### TreeSet（二叉树）
* TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。
* Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的， 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。
* 在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序
* 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数
### LinkHashSet（ HashSet+LinkedHashMap）
对于 LinkedHashSet 而言，它继承于 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。