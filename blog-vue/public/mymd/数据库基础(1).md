# 数据库基础(1)
## 数据库范式
- 1NF(第一范式)：属性不可再分。
- 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。
- 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。
## 为什么不推荐使用外键与级联？
> 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度
## 什么是存储过程?
我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。
> 存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。
## drop、delete 与 truncate 区别？
**drop(丢弃数据)**: drop table 表名 ，直接将表都删除掉，在删除表的时候使用。
**truncate (清空数据)** : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
**delete（删除数据）** : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。
> truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。
## 数据库设计通常分为哪几步?
- **需求分析** : 分析用户的需求，包括数据、功能和性能需求。
- **概念结构设计** : 主要采用 E-R 模型进行设计，包括画 E-R 图。
- **逻辑结构设计** : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
- **物理结构设计** : 主要是为所设计的数据库选择合适的存储结构和存取路径。
- **数据库实施** : 包括编程、测试和试运行数据库的运行和维护 : 系统的运行与数据库的日常维护。
## MySQL 字段类型
- **数值类型**：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- **字符串类型**：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
- **日期时间类型**：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。
## 整数类型的 UNSIGNED 属性有什么用？
MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。
## CHAR 和 VARCHAR 的区别是什么？
- **CHAR** 和 **VARCHAR** 是最常用到的字符串类型，两者的主要区别在于：**CHAR **是定长字符串，**VARCHAR** 是变长字符串。
- **CHAR **在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；**VARCHAR **在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。
- **CHAR **更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。**VARCHAR** 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。
- **CHAR**(M) 和 **VARCHAR**(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。
## DECIMAL 和 FLOAT/DOUBLE 的区别是什么？
- **DECIMAL **和 **FLOAT **的区别是：**DECIMAL **是定点数，**FLOAT/DOUBLE** 是浮点数。
- **DECIMAL **可以存储精确的小数值，**FLOAT/DOUBLE** 只能存储近似的小数值。**DECIMAL **用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。
## 为什么不推荐使用 TEXT 和 BLOB？
TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。
数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：
- 不能有默认值。
- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。
- 检索效率较低。
- 不能直接创建索引，需要指定前缀长度。
- 可能会消耗大量的网络和 IO 带宽。
- 可能导致表上的 DML 操作变慢。
## NULL 和 '' 的区别是什么？
- NULL 代表一个不确定的值,就算是两个 NULL,它俩也不一定相等。例如，SELECT NULL=NULL的结果为 false，但是在我们使用DISTINCT,GROUP BY,ORDER BY时,NULL又被认为是相等的。
- ''的长度是 0，是不占用空间的，而NULL 是需要占用空间的。
- NULL 会影响聚合函数的结果。例如，SUM、AVG、MIN、MAX 等聚合函数会忽略 NULL 值。 COUNT 的处理方式取决于参数的类型。如果参数是 *(COUNT(*))，则会统计所有的记录数，包括 NULL 值；如果参数是某个字段名(COUNT(列名))，则会忽略 NULL 值，只统计非空值的个数。
- 查询 NULL 值时，必须使用 IS NULL 或 IS NOT NULLl 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而''是可以使用这些比较运算符的。
## Boolean 类型如何表示？
MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。
## 了解过索引吗? (什么是索引)，可以使用expalain+sql语句查看索引命中状态
- 索引(index)是帮助MySQL高效获取数据的数据结构(有序)
- 提高数据检索的效率，降低数据库的IO成本(不需要全表扫描)
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗
## 索引的底层数据结构了解过嘛?
- MySQL的InnoDB引擎采用的B+树的数据结构来存储索引
- 阶数更多，路径更短
- 磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据
- B+树便于扫库和区间查询，叶子节点是一个双向链表
## 什么是聚簇索引什么是非聚簇索引?
- 聚簇索引(聚集索引): 数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个
- 非聚簇索引(二级索引):数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个
## 知道什么是回表查询嘛?
通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表
## 知道什么叫覆盖索引嘛?
覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到
- 使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。
- 如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select *
## 索引创建的原则
- 数据量较大，且查询比较频繁的表
- 常作为查询条件、排序、分组的字段
- 字段内容区分度高
- 内容较长，使用前缀索引
- 尽量联合索引
- 要控制索引的数量
## 什么情况下索引会失效
- 违反最左前缀法则
- 范围查询右边的列，不能使用索引
- 不要在索引列上进行运算操作，索引将失效
- 字符串不加单引号，造成索引失效。(类型转换)
- 以%开头的Like模糊查询，索引失效
## sql优化经验
- 表的设计优化，数据类型的选择
- 索引优化，索引创建原则
- sql语句优化，避免索引失效，避免使用select *
- 主从复制、读写分离，不让数据的写入，影响读操作
- 分库分表



