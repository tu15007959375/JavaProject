# AOP(Aspect Orient Programming)
## 什么是AOP？
面向切面编程，作为面向对象的一种补充，将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但所有业务模块都会调用的公共逻辑
## Spring AOP相关术语
- 切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。
- 连接点（Join point）：指方法，在Spring AOP中，一个连接点总是代表一个方法的执行。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。
- 通知（Advice）：在AOP术语中，切面的工作被称为通知。
- 切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。
- 引入（Introduction）：引入允许我们向现有类添加新方法或属性。
- 目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。
- 织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命
周期里有以下时间点可以进行织入：
  - 编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。
  - 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。
  - 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。
## Spring通知有哪些类型？
在AOP术语中，切面的工作被称为通知。通知实际上是程序运行时要通过Spring AOP框架来触发的代码段。
Spring切面可以应用5种类型的通知：
1. 前置通知（Before）：在目标方法被调用之前调用通知功能；
2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；
3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；
4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；
5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的逻辑。
## AOP有哪些实现方式？
### 静态代理
静态代理：代理类在编译阶段生成，在编译阶段将通知织入Java字节码中，也称编译时增强。AspectJ使用的是静态代理。
缺点：代理对象需要与目标对象实现一样的接口，并且实现接口的方法，会有冗余代码。同时，一旦接口增加方法，目标对象与代理对象都要维护。
### 动态代理
动态代理：代理类在程序运行时创建，AOP框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类。
## Spring AOP的实现原理
Spring 的 AOP 实现原理其实很简单，就是通过动态代理实现的。如果我们为 Spring 的某个 bean 配置了切面，那么 Spring 在创建这个 bean 的时候，实际上创建的是这个 bean 的一个代理对象，我们后续对 bean 中方法的调用，实际上调用的是代理类重写的代理方法。而 Spring 的 AOP 使用了两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理
## JDK动态代理和CGLIB动态代理的区别？
### JDK动态代理
如果目标类实现了接口，Spring AOP会选择使用JDK动态代理目标类。代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口。JDK动态代理的核心是InvocationHandler 接口和 Proxy 类。
缺点：目标类必须有实现的接口。如果某个类没有实现接口，那么这个类就不能用JDK动态代理。
### CGLIB动态代理
通过继承实现。如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library）可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用CGLIB做动态代理的。
优点：目标类不需要实现特定的接口，更加灵活。

什么时候采用哪种动态代理？
- 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP
- 如果目标对象实现了接口，可以强制使用CGLIB实现AOP
- 如果目标对象没有实现了接口，必须采用CGLIB库
### 两者的区别：
- jdk动态代理使用jdk中的类Proxy来创建代理对象，它使用反射技术来实现，不需要导入其他依赖。cglib需要引入相关依赖： asm.jar ，它使用字节码增强技术来实现。
- 当目标类实现了接口的时候Spring Aop默认使用jdk动态代理方式来增强方法，没有实现接口的时候使用cglib动态代理方式增强方法。
## 你们项目中有没有使用到AOP
- 记录操作日志，缓存，spring实现的事务
- 核心是:使用aop中的环绕通知+切点表达式(找到要记录日志的方法)通过环绕通知的参数获取请求方法的参数(类、方法、注解、请求方式)等，获取到这些参数以后，保存到数据库
## 统⼀异常处理怎么做？
- 推荐使⽤注解的⽅式统⼀异常处理，具体会使⽤到 @ControllerAdvice + @ExceptionHandler 这两个注解 。
- 这种异常处理⽅式下，会给所有或者指定的 Controller 织⼊异常处理的逻辑（AOP），当
Controller 中的⽅法抛出异常的时候，由被 @ExceptionHandler 注解修饰的⽅法进⾏处理。
- ExceptionHandlerMethodResolver 中 getMappedMethod ⽅法决定了异常具体被哪个被@ExceptionHandler 注解修饰的⽅法处理异常
## Spring 管理事务的⽅式有⼏种
- **编程式事务** ： 在代码中硬编码(不推荐使⽤) : 通过 TransactionTemplate 或者
TransactionManager ⼿动管理事务，实际应⽤中很少使⽤，但是对于你理解 Spring 事务管理原理有帮助。
- **声明式事务** ： 在 XML 配置⽂件中配置或者直接基于注解（推荐使⽤） : 实际是通过 AOP 实现（基于 @Transactional 的全注解⽅式使⽤最多）
## Spring中的事务是如何实现的
其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务
## Spring中事务失效的场景有哪些
- 异常捕获处理，自己处理了异常，没有抛出，解决: 手动抛出
- 抛出检查异常，配置rollbackFor属性为Exception
- 非public方法导致的事务失效，改为public
## Spring 事务中哪⼏种事务传播⾏为?
事务传播⾏为是为了解决业务层⽅法之间互相调⽤的事务问题
正确的事务传播⾏为可能的值如下:
- **TransactionDefinition.PROPAGATION_REQUIRED**
使⽤的最多的⼀个事务传播⾏为，我们平时经常使⽤的 @Transactional 注解默认使⽤就是这个事务传播⾏为。如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务。
- **TransactionDefinition.PROPAGATION_REQUIRES_NEW**
创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部⽅法是否开启事
务， Propagation.REQUIRES_NEW 修饰的内部⽅法会新开启⾃⼰的事务，且开启的事务相互独⽴，互不⼲扰。
- **TransactionDefinition.PROPAGATION_NESTED**
如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED 。
- **TransactionDefinition.PROPAGATION_MANDATORY**
如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

若是错误的配置以下 3 种事务传播⾏为，事务将不会发⽣回滚：
- **TransactionDefinition.PROPAGATION_SUPPORTS** : 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。
- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED** : 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NEVER** : 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。
## @Transactional(rollbackFor = Exception.class)注解了解吗
- Exception 分为运⾏时异常 RuntimeException 和⾮运⾏时异常。事务管理对于企业应⽤来说是⾄关重要的，即使出现异常情况，它也可以保证数据的⼀致性。
- 当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，同时，我们也可以在⽅法级别使⽤该标注来覆盖类级别的定义。如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。
- 在 @Transactional 注解中如果不配置 rollbackFor 属性,那么事务只会在遇到 RuntimeException 的时候才会回滚，加上 rollbackFor=Exception.class ,可以让事务在遇到⾮运⾏时异常时也回滚。