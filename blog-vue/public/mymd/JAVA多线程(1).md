# JAVA多线程(1)
* 优点：提高了程序的执行效率，一定情况下可以提高程序运行速度。
* 缺点：可能出现内存泄漏、上下文切换、线程安全、死锁等问题。
## 并发编程三要素是什么？
* 原子性：一个操作是不可分割的，要么全部执行成功要么全部执行失败。
* 可见性：一个线程对共享变量的值进行修改后，另一个线程能够立刻看到修改的值。（synchronized,volatile）
* 有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行指令重排）
### 指令重排
指令重排：虚拟机在进行代码编时，对于那些改变顺序后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码顺序来执行，有可能将他们重排序。实际上对有些代码进行重排序后，虽然对变量的值没有造成影响，但有可能出现线程安全问题。
## 进程与线程的区别
* 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
* 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，所以系统在产生⼀个线程，或是在各个线程之间作切换⼯作时，开销要⽐进程小得多，所以线程也被称为轻量级进程
* 内存分配：进程与进程之间的地址空间和资源是相互独立的，同一进程的线程共享本进程的地址空间和资源，线程之间可能会相互影响。
* 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。
* 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
## 如何保证线程安全？
* 方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger
* 方法二：使用JVM提供的自动锁 synchronized。
* 方法三：使用JDK提供的手动锁 Lock。
## synchronized关键字
* synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。
* synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
* 三种使用方式：
   * 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
   * 修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
   * 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 
  
* 总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能
## JMM(Java 内存模型)
在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，就需要把变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
## volatile 关键字
* Java 提供了 volatile 关键字是线程同步的轻量级实现，用来保证可见性和有序性（禁止指令重排），volatile 常用于多线程环境下的单次操作(单次读或者单次写)。
* 可见性：对于加了 volatile关键字的成员变量，在对这个变量进行修改时，全直接将CPU高级缓存中的数据送回到主内存,对这个变量的读取也会直接从主内存中读取，从而保证了可见性
* 有序性：在对 volatile修饰的成员变量进行读写时，会插入内存屏障，而内存屏障可以达到禁止重排序的效果，从而可以保证有序性
* volatile可以和CAS 结合，来保证原子性。

## volatile实现
### volatile实现内存可见性
一个问题：本地内存和主内存之间的值不一致，导致内存不可见。
在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令。将当前处理器缓存行的数据写回系统内存，这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效，当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。
### volatile实现有序性
为了实现volatile的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。
内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。
## CAS(Compare And Swap)
* CAS即Compare And Swap，比较并替换。是一条CPU并发原语，Java中可以通过CAS操作来保证原子性，它的功能是判断内存某个位置的值是否为预期值，如果是则更新为新的值，这个过程是原子的。
* CAS并发原语提现在Java语言中就是sun.misc.UnSafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我实现CAS汇编指令。这是一种完全依赖于硬件功能，通过它实现了原子操作。原语的执行必须是连续的，在执行过程中不允许中断，也即是说CAS是一条原子指令，不会造成所谓的数据不一致的问题。
* Unsafe：CAS的核心类，Java方法无法直接访问内存，需要通过本地方法native来访问，在Unsafe中所有方法都是native方法，用来直接操作内存，执行相应的任务。
* CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。类似于乐观锁。CAS自旋的概率会比较大，从而浪费更多的CPU资源。在这个过程中可能存在ABA问题：
当你获得对象当前数据后，在准备修改为新值前，对象的值被其他线程连续修改了两次（A->B->A），而经过两次修改后，对象的值又恢复为旧值，这样当前线程无法正确判断这个对象是否修改过。
* ABA的问题的解决方式：
   * ABA的解决方法也很简单，就是利用版本号。给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使E的值从A—>B—>A，版本号也发生了变化，这样就解决了CAS出现的ABA问题。基于CAS的乐观锁也是这个实现原理。
   * JDK1.5时可以利用AtomicStampedReference类来解决这个问题，AtomicStampedReference内部不仅维护了对象值，还维护了一个时间戳。当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳，对象值和时间戳都必须满足期望值，写入才会成功
* 自旋：当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。
## synchronized 关键字和 volatile 关键字的区别
* synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！
* volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比synchronized关键字要好 。
* volatile 关键字只能用于变量，而synchronized 关键字可以修饰方法以及代码块 。
* volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
* volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。
## xxx = new Xxx(); 
* 这段代码其实是分为三步执行：
* 为 uniqueInstance 分配内存空间
* 初始化 uniqueInstance
* 将 uniqueInstance 指向分配的内存地址
* 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。



