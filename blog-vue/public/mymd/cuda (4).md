# 学习日记-cuda(4)
## cuda共享内存
### **共享内存**
![rel](/mymd/学习日记-cuda（4）/rel.png)
* SM上有共享内存，L1一级缓存，ReadOnly 只读缓存，Constant常量缓存。所有从Dram全局内存中过来的数据都要经过二级缓存，相比之下，更接近SM计算核心的SMEM，L1，ReadOnly，Constant拥有更快的读取速度，SMEM和L1相比于L2延迟低大概20~30倍，带宽大约是10倍。
* 共享内存是在他所属的线程块被执行时建立，线程块执行完毕后共享内存释放，线程块和他的共享内存有相同的生命周期。
* 共享内存的生命周期是和其所属的线程块相同的，这个共享内存是编程模型层面上的。物理层面上，一个SM上的所有的正在执行的线程块共同使用物理的共享内存，所以共享内存也成为了活跃线程块的限制，共享内存越大，或者块使用的共享内存越小，那么线程块级别的并行度就越高。
* 声明共享内存通过关键字：`__shared__`,这里的size_x,size_y和声明c++数组一样，要是一个编译时确定的数字，不能是变量。
### **同步**
* 同步基本方法：障碍；内存栅栏
* 显示障碍：`void __syncthreads();`,这个指令只能在核函数中调用，并只对同一线程块内线程有效
* 内存栅栏:
    * 1. 线程块内：`void __threadfence_block();`,保证同一块中的其他线程对于栅栏前的内存写操作可见
    * 2. 网格级内存栅栏:`void __threadfence();`挂起调用线程，直到全局内存中所有写操作对相同的网格内的所有线程可见
    * 3. 系统级栅栏，跨系统，包括主机和设备：`void __threadfence_system();`挂起调用线程，以保证该线程对全局内存，锁页主机内存和其他设备内存中的所有写操作对全部设备中的线程和主机线程可见。
### **Volatile修饰符**
* volatile声明一个变量，防止编译器优化，防止这个变量存入缓存，如果恰好此时被其他线程改写，那就会造成内存缓存不一致的错误，所以volatile声明的变量始终在全局内存中。