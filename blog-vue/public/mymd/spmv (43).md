# SPMV稀疏矩阵向量乘笔记（43）
## Adaptive diagonal sparse matrix-vector multiplication on GPU 浅读 (1)
### **Introduction**
* 对于基本并行计算而言，gpu已经变成了一个强有力的竞争对手，而spmv则显得尤为重要
* 而稀疏矩阵中有相当一部分是对角矩阵，所以如何解决对角矩阵的spmv计算也是非常必要的
* 需要解决这个问题，有两个主要因素：合适的矩阵格式；在全局内存中高效的访存
* 虽然目前已经有了DIA格式，但是当一些对角元素原理主对角元，或者对角线上有一段长的零元素段时，或者有一些散列分布的点时，DIA格式就需要填充非常多的零元素来保持它的结构性，如图所示

![DIAdis](/mymd/学习日记-spmv（43）/DIAdis.png)
* CRSD格式是为了应该这种情况的存储格式，但是有两个问题，一是构成太复杂了，而是没有给出源码
* HDI格式也是为了解决问题，但是当许多对角线元素都远离主对角线时，HDI所构造的子矩阵并不能减轻非零元填充问题，因为它的子矩阵也用的是DIA格式
* 为了解决这个问题，决定将对角矩阵分为三类，第一类为所有的对角线都离主对角线不远，并且没有离散的点和对角线没有连续的零元，第二类为存在对角线离主对角线远，然后其他和第一类一样。第三类为除开前面这两类的
* 对于第一类，更适合使用DIA，对于后两种，因为再使用DIA的话，需要大量的零元填充，所以使用了新的存储格式，BRCSD-I，BRCSD-II
* 为了决定给出一个矩阵，应该使用哪种存储格式，设计了一个搜索引擎，来决定矩阵使用哪种存储格式并且生成相应的kernel代码，因为每次输出矩阵都需要重新生成代码，所以为了减轻这个缺点，设计了一个代码生成器去自动生成代码，对于第一类的矩阵，只需要使用DIA格式并且调用DIA的kernel即可

![kinds](/mymd/学习日记-spmv（43）/kinds.png)
### **GPU implementations**
![framework](/mymd/学习日记-spmv（43）/framework.png)
* 总共包括三部分：矩阵格式和kernel，代码生成器，搜索引擎
* ### DIA kernel
格式如下：
![dia](/mymd/学习日记-spmv（43）/dia.png)
伪代码如下：
![dia%20kernel](/mymd/学习日记-spmv（43）/dia%20kernel.png)
* ### BRCSD-I format & kernel  
* 格式案例如下:
![brcsd1](/mymd/学习日记-spmv（43）/brcsd1.png)
* 获取方式：首先生成p数组，由offset中0左侧的绝对值，m-1-0右侧的值，0，m-1放一起后再排序构成，然后设定一个阈值，将p数组i+1的值减i，小于则删除i+1，重复此动作。注：第一次减的时候要加一,并且最后一个元素必须保留（本应该删除2，5）  
* ex:p为[0,1,2,4,5],阈值为1，则剩下了[0,1,5]，通过该数组将矩阵分块
![brcsd1%20ex](/mymd/学习日记-spmv（43）/brcsd1%20ex.png)
* 为了负载均衡，需要将行数大于总行数/block大小值的row piece进行分块，并且为了方便计算，在确定row piece时，也将每个row piece的大小设置为每个线程块中线程数的倍数
* ### BRCSD-II format & kernel  
* 第一种存储格式并不能解决离散的非零元问题，所以提出了第二种
![IIex](/mymd/学习日记-spmv（43）/IIex.png)
![orin&I](/mymd/学习日记-spmv（43）/orin&I.png)
* 如图，按照DIA或者第一种的话，非零元个数依旧非常高，将矩阵根据行数/nrows分块，nrows为自己设定，然后进行DIA记录，并且如果有相同的offset，就合并他们的offset
